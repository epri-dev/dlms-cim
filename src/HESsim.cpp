// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <time.h>
#include <ctype.h>
#include <unistd.h>
#include <iomanip>
#include <asio.hpp>
#include <algorithm>
#include <string>


#include "LinuxBaseLibrary.h"
#include "LinuxCOSEMServer.h"

#include "HDLCLLC.h"
#include "COSEM.h"
#include "UUID.h"
#include "serialwrapper/SerialWrapper.h"
#include "tcpwrapper/TCPWrapper.h"
#include "dlms-cimConfig.h"

#include "EndDeviceControls_USCOREBinding.nsmap"        // XML namespace mapping table (only needed once at the global level)
#include "soapEndDeviceControls_USCOREBindingService.h"

using namespace std;
using namespace EPRI;
using namespace asio;

class LinuxClientEngine : public COSEMClientEngine
{
public:
    LinuxClientEngine() = delete;
    LinuxClientEngine(const Options& Opt, Transport * pXPort)
        : COSEMClientEngine(Opt, pXPort)
    {
    }
    virtual ~LinuxClientEngine()
    {
    }
    
    virtual bool OnOpenConfirmation(COSEMAddressType ServerAddress)
    {
        Base()->GetDebug()->TRACE("\n\nAssociated with Server %d...\n\n",
            ServerAddress);
        return true;
    }

    virtual bool OnGetConfirmation(RequestToken Token, const GetResponse& Response)
    {
        Base()->GetDebug()->TRACE("\n\nGet Confirmation for Token %d...\n", Token);
        if (Response.ResultValid && Response.Result.which() == Get_Data_Result_Choice::data_access_result)
        {
            Base()->GetDebug()->TRACE("\tReturned Error Code %d...\n", 
                Response.Result.get<APDUConstants::Data_Access_Result>());
            return false;
        }
        
        if (CLSID_IData == Response.Descriptor.class_id)
        {
            IData     SerialNumbers;
            DLMSValue Value;
        
            SerialNumbers.value = Response.Result.get<DLMSVector>();
            if (COSEMType::VALUE_RETRIEVED == SerialNumbers.value.GetNextValue(&Value))
            {
                Base()->GetDebug()->TRACE("%s\n", DLMSValueGet<VISIBLE_STRING_CType>(Value).c_str());
            }
           
        }
        else if (CLSID_IAssociationLN == Response.Descriptor.class_id)
        {
            IAssociationLN CurrentAssociation;
            DLMSValue      Value;
            
            switch (Response.Descriptor.attribute_id)
            {
            case IAssociationLN::ATTR_PARTNERS_ID:
                {
                    CurrentAssociation.associated_partners_id = Response.Result.get<DLMSVector>();
                    if (COSEMType::VALUE_RETRIEVED == CurrentAssociation.associated_partners_id.GetNextValue(&Value) &&
                        IsSequence(Value))
                    {
                        DLMSSequence& Element = DLMSValueGetSequence(Value);
                        Base()->GetDebug()->TRACE("ClientSAP %d; ServerSAP %d\n", 
                            DLMSValueGet<INTEGER_CType>(Element[0]),
                            DLMSValueGet<LONG_UNSIGNED_CType>(Element[1]));
                    }
                }
                break;
            
            default:
                Base()->GetDebug()->TRACE("Attribute %d not supported for parsing.", Response.Descriptor.attribute_id);
                break;
            }
        }
        return true;
    }
    
    virtual bool OnSetConfirmation(RequestToken Token, const SetResponse& Response)
    {
        Base()->GetDebug()->TRACE("\n\nSet Confirmation for Token %d...\n", Token);
        if (Response.ResultValid)
        {
            Base()->GetDebug()->TRACE("\tResponse Code %d...\n", 
                Response.Result);
        }
        return true;
    }

    virtual bool OnActionConfirmation(RequestToken Token, const ActionResponse& Response)
    {
        Base()->GetDebug()->TRACE("\n\nAction Confirmation for Token %d...\n", Token);
        if (Response.ResultValid)
        {
            Base()->GetDebug()->TRACE("\tResponse Code %d...\n", 
                Response.Result);
        }
        return true;
    }
    
    virtual bool OnReleaseConfirmation()
    {
        Base()->GetDebug()->TRACE("\n\nRelease Confirmation from Server\n\n");
        return true;
    }
    
    virtual bool OnReleaseConfirmation(COSEMAddressType ServerAddress)
    {
        Base()->GetDebug()->TRACE("\n\nRelease Confirmation from Server %d\n\n", ServerAddress);
        return true;
    }

    virtual bool OnAbortIndication(COSEMAddressType ServerAddress)
    {
        if (INVALID_ADDRESS == ServerAddress)
        {
            Base()->GetDebug()->TRACE("\n\nAbort Indication.  Not Associated.\n\n");
        }
        else
        {
            Base()->GetDebug()->TRACE("\n\nAbort Indication from Server %d\n\n", ServerAddress);
        }
        return true;
    }

};

LinuxBaseLibrary     bl;

bool serviceConnect(bool reconnect, const std::string& meterURL) 
{
    bool success{false};
    // composed of:
    // A. TCP connect
    int         SourceAddress = 1; //GetNumericInput("Client Address (Default: 1)", 1);
    ISocket *                       m_pSocket = nullptr;

    auto m_pClientEngine = new LinuxClientEngine(COSEMClientEngine::Options(SourceAddress), 
        new TCPWrapper((m_pSocket = Base()->GetCore()->GetIP()->CreateSocket(LinuxIP::Options(LinuxIP::Options::MODE_CLIENT, LinuxIP::Options::VERSION6)))));
    if (SUCCESSFUL != m_pSocket->Open(meterURL.c_str()))
    {
        std::cout << "Failed to initiate connect to " << meterURL << "\n";
        return success;
    }
        // 1. COSEM Open
    int tries{400};
    do {
        bl.get_io_service().poll();
        if (m_pSocket && m_pSocket->IsConnected() && m_pClientEngine->IsTransportConnected()) 
        {
            bool                 Send = true;
            int                  DestinationAddress = 1; //GetNumericInput("Server Address (Default: 1)", 1);
            COSEMSecurityOptions::SecurityLevel Security = COSEMSecurityOptions::SECURITY_NONE;
           // (COSEMSecurityOptions::SecurityLevel)
                //GetNumericInput("Security Level [0 - None, 1 - Low, 2 - High] (Default: 0)", COSEMSecurityOptions::SECURITY_NONE);
            COSEMSecurityOptions SecurityOptions; 
            //
            // Only supports LN at this time
            //
            SecurityOptions.ApplicationContextName = SecurityOptions.ContextLNRNoCipher;
            size_t APDUSize = 640; // GetNumericInput("APDU Size (Default: 640)", 640);
            m_pClientEngine->Open(DestinationAddress,
                                  SecurityOptions, 
                                  xDLMS::InitiateRequest(APDUSize));
        }
        else
        {
            // std::cout << "Transport Connection Not Established Yet!\n";
            --tries;
        }
    } while (!(m_pSocket && m_pSocket->IsConnected() && m_pClientEngine->IsTransportConnected()) && tries > 0);
    if (tries <= 0) {
        return success;
    }
    tries = 400;
        // 4. COSEM Action
        //  class ID = 70
        //  method = 1 (disconnect)
        //  OBIS Code = 0-0:96.3.10*255
        //  Parameter 1 (don't care)
    COSEMClientEngine::RequestToken m_ActionToken; 
    do {
        bl.get_io_service().poll();
        if (m_pSocket && m_pSocket->IsConnected() && m_pClientEngine->IsOpen())
        {
            Cosem_Method_Descriptor Descriptor;

            Descriptor.class_id = CLSID_Disconnect;
            Descriptor.method_id = (ObjectAttributeIdType)(reconnect ? 2 : 1);
            if (Descriptor.instance_id.Parse("0-0:96.3.10*255"))
            {
                COSEMType MyData(COSEMDataType::INTEGER, 1); 
                if (m_pClientEngine->Action(Descriptor,
                                        DLMSOptional<DLMSVector>(MyData),
                                        &m_ActionToken))
                {
                    std::cout << std::string("\tAction Request Sent: Token ") + std::to_string(m_ActionToken) + "\n";
                }
            }
            else
            {
                std::cout << "Malformed OBIS Code!\n";
            }
        }
        else
        {
            // std::cout << "Not Connected!\n"; 
            --tries;
        }
        
    } while (!(m_pSocket && m_pSocket->IsConnected() && m_pClientEngine->IsOpen()) && tries > 0);
        // 5. COSEM Disconnect
    {
        if (!m_pClientEngine->Release(xDLMS::InitiateRequest()))
        {
            std::cout << "Problem submitting COSEM Release!\n";
        }
    }
        // T. TCP Disconnect
    {
        if (m_pSocket)
        {
            Base()->GetCore()->GetIP()->ReleaseSocket(m_pSocket);
            m_pSocket = nullptr;
            std::cout << "Socket released.\n";
            success = true;
        }
        else
        {
            std::cout << "TCP Not Opened!\n";
        }
    }
    return success;
}

std::vector<std::string> meters{};

int main(int argc, char *argv[]) {
    int port;
    if (argc > 1) {
        port = std::atoi(argv[1]);
    }
    if (port <= 0) {
        port = 8080;
    }
    for (int i=2; i < argc; ++i) {
        meters.emplace_back(std::string{argv[i]});
    }
    std::cout << "Starting Head End System simulator on port " << port << '\n';
    EndDeviceControls_USCOREBindingService hes(SOAP_XML_INDENT);
    hes.soap->send_timeout = 5; // send timeout is 5s
    hes.soap->recv_timeout = 5; // receive timeout is 5s
    if (hes.run(port) != SOAP_OK && hes.soap->error != SOAP_TCP_ERROR) {
        hes.soap_stream_fault(std::cerr);
        std::cout << "ERROR: unable to start Head End System simulator on port " << port << '\n';
    }
    hes.destroy(); 
    std::cout << "Shut down Head End Server on port " << port << '\n';
}

// simple helper struct to translate requested meter names into URLs
struct Device {
    std::string request;
    std::string url; 
    bool failed = true;
    Device(std::string devname) : request{devname} {
        auto num = atoi(&(devname[1])) - 1001;
        if (num >= 0 && num < meters.size()) {
            url = meters[num];
        }
    }
};

/// Web service operation 'CreateEndDeviceControls' implementation, should return SOAP_OK or error code
int EndDeviceControls_USCOREBindingService::CreateEndDeviceControls(ns2__EndDeviceControlsRequestMessageType *req, ns2__EndDeviceControlsResponseMessageType &resp) {
    static std::string disconnectRef{"3.31.0.23"};
    static std::string reconnectRef{"3.31.0.18"};
    // remember the ReplyAddress
    if (req->Header->Verb == _ns3__HeaderType_Verb::create) {
        std::cout << "We got a create message\n";
    }
    bool reconnect{false};

    // make sure the devices exist
    std::vector<Device> victims;
    if (req->Payload) {
        for (ns4__EndDeviceControls* edcs: req->Payload->ns4__EndDeviceControls_) {
            if (edcs) {
                for (ns4__EndDeviceControl* edc: edcs->EndDeviceControl) {
                    if (edc) {
                        auto ref{edc->EndDeviceControlType.ref};
                        if (ref && *ref == disconnectRef) {
                            reconnect = false;
                        }
                        if (ref && *ref == reconnectRef) {
                            reconnect = true;
                        }
                        if (edc->EndDevices.size()) {
                            for (auto name: edc->EndDevices.front()->Names) {
                                victims.emplace_back(Device(name->name));
                                std::cout << name->name << '\n';
                            }
                        }
                    }
                }
            }
        }
    }    
    // if they do, send the outbound messages
    for (auto& meter: victims) {
        if (!meter.url.empty()) {
            auto success{serviceConnect(reconnect, meter.url)};
            meter.failed = !success;
            std::cout << (reconnect ? "reconnecting" : "disconnecting")
                << " meter at " << meter.url 
                << (success ? "... OK\n" : "... FAILED!\n");
        }
    }
    // and send the response
    resp.Header = soap_new_req_ns3__HeaderType(soap,
        _ns3__HeaderType_Verb::reply,   // Verb
        "EndDeviceControls",  // Noun
        std::chrono::system_clock::now(),  // Timestamp
        UUID::random(),   // MessageID
        req->Header->CorrelationID  // CorrelationID
    );
    /* If everything is OK, just send 0.0 */
    if (all_of(victims.begin(), victims.end(), [](Device &d){ return !d.failed; })) {
        resp.Reply = soap_new_req_ns3__ReplyType(soap, _ns3__ReplyType_Result::OK);
        resp.Reply->Error.emplace_back(soap_new_req_ns3__ErrorType(soap, "0.0"));
        resp.Reply->Error.back()->level = soap_new__ns3__ErrorType_level(soap);
    } else {
        resp.Reply = soap_new_req_ns3__ReplyType(soap, _ns3__ReplyType_Result::FAILED);
        for (auto& meter: victims) {
            if (meter.failed) { 
                bool nonExisting{meter.url.empty()};
                resp.Reply->Error.emplace_back(soap_new_req_ns3__ErrorType(soap, 
                    nonExisting ? "2.12" : "2.4"));
                resp.Reply->Error.back()->level = soap_new__ns3__ErrorType_level(soap, 2);
                *(resp.Reply->Error.back()->level) = _ns3__ErrorType_level::FATAL;
                resp.Reply->Error.back()->ID = soap_new_req__ns3__ErrorType_ID(soap, meter.request);
                resp.Reply->Error.back()->ID->kind = soap_new_ns3__IDKindType(soap);
                resp.Reply->Error.back()->ID->objectType = soap_new_std__string(soap);
                resp.Reply->Error.back()->ID->objectType->append("Meter");
            }
        }
    }
    return SOAP_OK;
}

//
/// Web service operation 'ChangeEndDeviceControls' implementation, should return SOAP_OK or error code
int EndDeviceControls_USCOREBindingService::ChangeEndDeviceControls(ns2__EndDeviceControlsRequestMessageType *req, ns2__EndDeviceControlsResponseMessageType &resp) {
    if (req->Header->Verb == _ns3__HeaderType_Verb::change) {
        std::cout << "We got a change message\n";
    }
    resp.Header = soap_new_req_ns3__HeaderType(soap,
        _ns3__HeaderType_Verb::reply,   // Verb
        "EndDeviceControls",  // Noun
        std::chrono::system_clock::now(),  // Timestamp
        UUID::random(),   // MessageID
        req->Header->CorrelationID  // CorrelationID
    );
    resp.Reply = soap_new_req_ns3__ReplyType(soap,
        _ns3__ReplyType_Result::OK);
    
    return SOAP_OK;
}

//
/// Web service operation 'CancelEndDeviceControls' implementation, should return SOAP_OK or error code
int EndDeviceControls_USCOREBindingService::CancelEndDeviceControls(ns2__EndDeviceControlsRequestMessageType *req, ns2__EndDeviceControlsResponseMessageType &resp) {
    if (req->Header->Verb == _ns3__HeaderType_Verb::cancel) {
        std::cout << "We got a cancel message\n";
    }
    resp.Header = soap_new_req_ns3__HeaderType(soap,
        _ns3__HeaderType_Verb::reply,   // Verb
        "EndDeviceControls",  // Noun
        std::chrono::system_clock::now(),  // Timestamp
        UUID::random(),   // MessageID
        req->Header->CorrelationID  // CorrelationID
    );
    resp.Reply = soap_new_req_ns3__ReplyType(soap,
        _ns3__ReplyType_Result::OK);
    
    return SOAP_OK;
}

//
/// Web service operation 'CloseEndDeviceControls' implementation, should return SOAP_OK or error code
int EndDeviceControls_USCOREBindingService::CloseEndDeviceControls(ns2__EndDeviceControlsRequestMessageType *req, ns2__EndDeviceControlsResponseMessageType &resp) {
    if (req->Header->Verb == _ns3__HeaderType_Verb::close) {
        std::cout << "We got a close message\n";
    }
    resp.Header = soap_new_req_ns3__HeaderType(soap,
        _ns3__HeaderType_Verb::reply,   // Verb
        "EndDeviceControls",  // Noun
        std::chrono::system_clock::now(),  // Timestamp
        UUID::random(),   // MessageID
        req->Header->CorrelationID  // CorrelationID
    );
    resp.Reply = soap_new_req_ns3__ReplyType(soap,
        _ns3__ReplyType_Result::OK);
    
    return SOAP_OK;
}

//
/// Web service operation 'DeleteEndDeviceControls' implementation, should return SOAP_OK or error code
int EndDeviceControls_USCOREBindingService::DeleteEndDeviceControls(ns2__EndDeviceControlsRequestMessageType *req, ns2__EndDeviceControlsResponseMessageType &resp) {
    if (req->Header->Verb == _ns3__HeaderType_Verb::delete_) {
        std::cout << "We got a delete message\n";
    }
    resp.Header = soap_new_req_ns3__HeaderType(soap,
        _ns3__HeaderType_Verb::reply,   // Verb
        "EndDeviceControls",  // Noun
        std::chrono::system_clock::now(),  // Timestamp
        UUID::random(),   // MessageID
        req->Header->CorrelationID  // CorrelationID
    );
    resp.Reply = soap_new_req_ns3__ReplyType(soap,
        _ns3__ReplyType_Result::OK);
    
    return SOAP_OK;
}

